<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNG Tweening Tool for Animators</title>
    <style>
        :root {
            --primary-color: #4a6baf;
            --secondary-color: #6d8ad6;
            --background-color: #f5f7ff;
            --accent-color: #ff7e5f;
            --text-color: #333;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        h1, h2, h3 {
            color: var(--primary-color);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--secondary-color);
        }

        .upload-section {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .upload-container {
            flex: 1;
            min-width: 280px;
            padding: 20px;
            border: 2px dashed var(--secondary-color);
            border-radius: var(--border-radius);
            text-align: center;
            transition: all 0.3s ease;
        }

        .upload-container:hover {
            border-color: var(--primary-color);
            background-color: rgba(74, 107, 175, 0.05);
        }

        .upload-label {
            display: block;
            margin-bottom: 15px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .file-input {
            display: none;
        }

        .upload-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .upload-button:hover {
            background-color: var(--secondary-color);
        }

        .preview-section {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        .preview-container {
            flex: 1;
            min-width: 280px;
            height: 280px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            padding: 10px;
            background-color: white;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .preview-title {
            position: absolute;
            top: 5px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--primary-color);
            z-index: 10;
        }

        .preview-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .controls-section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: rgba(74, 107, 175, 0.1);
            border-radius: var(--border-radius);
        }

        .settings-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .settings-column {
            flex: 1;
            min-width: 280px;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .action-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .action-button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }

        .action-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }

        .action-button.download {
            background-color: var(--accent-color);
        }

        .action-button.download:hover {
            background-color: #ff9a82;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .frame-input-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .frame-number-input {
            width: 60px;
            padding: 5px;
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
        }

        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #ddd;
            outline: none;
            border-radius: 4px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        .status-message {
            text-align: center;
            margin-top: 15px;
            color: var(--primary-color);
            font-weight: bold;
        }

        .method-container {
            margin-bottom: 15px;
        }

        .method-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .method-option {
            background-color: white;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .method-option:hover {
            background-color: rgba(74, 107, 175, 0.1);
            transform: translateY(-2px);
        }

        .method-option.selected {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .method-option.advanced::after {
            content: "Advanced";
            position: absolute;
            bottom: -7px;
            right: -7px;
            background-color: var(--accent-color);
            color: white;
            font-size: 0.65rem;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
        }

        /* Animation preview styles */
        .animation-preview-section {
            margin-top: 30px;
            margin-bottom: 30px;
        }

        .animation-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            background-color: #f8f8f8;
            position: relative;
        }
        
        .animation-preview {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
        }

        .animation-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .animation-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .animation-button:hover {
            background-color: var(--secondary-color);
        }

        .animation-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .playback-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .playback-label {
            font-weight: bold;
            color: var(--primary-color);
            min-width: 120px;
        }

        .playback-input {
            width: 60px;
            padding: 5px;
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
            text-align: center;
        }

        .playback-select {
            padding: 5px;
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
        }

        .progress-container {
            width: 100%;
            height: 4px;
            background-color: #ddd;
            position: absolute;
            bottom: 0;
            left: 0;
            border-bottom-left-radius: var(--border-radius);
            border-bottom-right-radius: var(--border-radius);
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--accent-color);
            width: 0%;
            transition: width 0.1s linear;
        }

        .frame-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--primary-color);
        }

        /* Easing visualization */
        .easing-viz {
            margin-top: 10px;
            width: 100%;
            height: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            display: none;
        }

        .easing-curve {
            width: 100%;
            height: 100%;
            background-color: #f8f8f8;
            position: relative;
        }

        .easing-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--accent-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Method-specific options */
        .method-specific-options {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            display: none;
        }

        .method-specific-options.visible {
            display: block;
        }

        .option-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .option-label {
            min-width: 120px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .option-slider {
            flex: 1;
        }

        .option-value {
            width: 40px;
            text-align: center;
        }

        /* Loading indicator */
        .loading {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(74, 107, 175, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .method-info {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--primary-color);
            display: none;
        }

        .method-info.visible {
            display: block;
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Color palette visualization */
        .color-palette-container {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .palette-row {
            display: flex;
            height: 20px;
        }

        .palette-color {
            flex: 1;
            height: 100%;
        }

        .palette-label {
            font-size: 0.8rem;
            margin-bottom: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PNG Tweening Tool for Animators</h1>
        
        <div class="upload-section">
            <div class="upload-container">
                <label class="upload-label">Starting Frame (PNG)</label>
                <input type="file" id="pngFile1" class="file-input" accept="image/png">
                <button class="upload-button" id="uploadButton1">Upload Starting PNG</button>
                <div id="fileName1" style="margin-top: 10px; font-size: 0.9rem;"></div>
            </div>
            
            <div class="upload-container">
                <label class="upload-label">Ending Frame (PNG)</label>
                <input type="file" id="pngFile2" class="file-input" accept="image/png">
                <button class="upload-button" id="uploadButton2">Upload Ending PNG</button>
                <div id="fileName2" style="margin-top: 10px; font-size: 0.9rem;"></div>
            </div>
        </div>
        
        <div class="controls-section">
            <div class="settings-row">
                <div class="settings-column">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Number of in-between frames:</span>
                            <div class="frame-input-container">
                                <input type="number" id="frameNumberInput" class="frame-number-input" min="1" max="100" value="4">
                            </div>
                        </div>
                        <input type="range" min="1" max="100" value="4" class="slider" id="interpolationSlider">
                    </div>
                    
                    <div class="method-container">
                        <label class="slider-label">Tweening Method:</label>
                        <div class="method-options">
                            <div class="method-option selected" data-method="crossfade">Crossfade</div>
                            <div class="method-option" data-method="pixelmotion">Pixel Motion</div>
                            <div class="method-option" data-method="morphological">Morphological</div>
                            <div class="method-option" data-method="colorharmonize">Color Harmonize</div>
                            <div class="method-option" data-method="dissolve">Dissolve</div>
                            <div class="method-option" data-method="wipe">Directional Wipe</div>
                            <div class="method-option" data-method="zoom">Zoom Blend</div>
                        </div>

                        <div id="methodInfo" class="method-info">
                            Crossfade: Simple opacity blending between frames. Good for smooth transitions.
                        </div>

                        <!-- Method-specific options -->
                        <div id="morphologicalOptions" class="method-specific-options">
                            <div class="option-row">
                                <span class="option-label">Edge Detection:</span>
                                <input type="range" min="0" max="100" value="50" class="slider option-slider" id="edgeIntensity">
                                <span class="option-value" id="edgeIntensityValue">50</span>
                            </div>
                            <div class="option-row">
                                <span class="option-label">Morph Strength:</span>
                                <input type="range" min="0" max="100" value="70" class="slider option-slider" id="morphStrength">
                                <span class="option-value" id="morphStrengthValue">70</span>
                            </div>
                            <div class="option-row tooltip">
                                <span class="option-label">Process Quality:</span>
                                <select id="morphQuality" class="playback-select">
                                    <option value="fast">Fast</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="high">High (Slower)</option>
                                </select>
                                <span class="tooltip-text">Higher quality provides better results but takes longer to process.</span>
                            </div>
                        </div>

                        <!-- Color Harmonize options -->
                        <div id="colorHarmonizeOptions" class="method-specific-options">
                            <div class="option-row">
                                <span class="option-label">Color Shift:</span>
                                <input type="range" min="0" max="100" value="75" class="slider option-slider" id="colorShiftIntensity">
                                <span class="option-value" id="colorShiftValue">75</span>
                            </div>
                            <div class="option-row">
                                <span class="option-label">Saturation:</span>
                                <input type="range" min="0" max="200" value="100" class="slider option-slider" id="saturationLevel">
                                <span class="option-value" id="saturationValue">100</span>%
                            </div>
                            <div class="option-row">
                                <span class="option-label">Preserve Luma:</span>
                                <input type="range" min="0" max="100" value="50" class="slider option-slider" id="preserveLuma">
                                <span class="option-value" id="preserveLumaValue">50</span>
                            </div>
                            <div class="option-row tooltip">
                                <span class="option-label">Palette Method:</span>
                                <select id="paletteMethod" class="playback-select">
                                    <option value="dominant">Dominant Colors</option>
                                    <option value="average" selected>Average Shift</option>
                                    <option value="hue">Hue Rotation</option>
                                </select>
                                <span class="tooltip-text">Different methods for transforming the color palette between images.</span>
                            </div>
                            <!-- Color Palette Visualization -->
                            <div class="color-palette-container">
                                <div>
                                    <div class="palette-label">Starting Image Palette:</div>
                                    <div class="palette-row" id="startPalette"></div>
                                </div>
                                <div>
                                    <div class="palette-label">Ending Image Palette:</div>
                                    <div class="palette-row" id="endPalette"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="settings-column">
                    <div class="playback-control">
                        <span class="playback-label">Animation Speed:</span>
                        <input type="number" id="fpsInput" class="playback-input" min="1" max="60" value="12"> fps
                    </div>
                    
                    <div class="playback-control">
                        <span class="playback-label">Easing Function:</span>
                        <select id="easingFunction" class="playback-select">
                            <option value="linear">Linear</option>
                            <option value="easeInQuad">Ease In</option>
                            <option value="easeOutQuad">Ease Out</option>
                            <option value="easeInOutQuad">Ease In/Out</option>
                            <option value="bounce">Bounce</option>
                            <option value="elastic">Elastic</option>
                        </select>
                    </div>
                    
                    <div id="easingVisualization" class="easing-viz">
                        <div class="easing-curve" id="easingCurve">
                            <div class="easing-point" id="easingPoint"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="action-button" id="generateButton" disabled>Generate In-Between Frames</button>
                <button class="action-button download" id="downloadButton" disabled>Download All Frames</button>
            </div>
            
            <div class="status-message" id="statusMessage"></div>
        </div>
        
        <h2>Frame Previews</h2>
        <div class="preview-section">
            <div class="preview-container">
                <div class="preview-title">Starting Frame</div>
                <img id="startingPngPreview" class="preview-image">
                <div class="loading" id="loading1">
                    <div class="loading-spinner"></div>
                </div>
            </div>
            
            <div class="preview-container">
                <div class="preview-title">25% Through</div>
                <img id="inBetween1Preview" class="preview-image">
                <div class="loading" id="loading2">
                    <div class="loading-spinner"></div>
                </div>
            </div>
            
            <div class="preview-container">
                <div class="preview-title">75% Through</div>
                <img id="inBetween2Preview" class="preview-image">
                <div class="loading" id="loading3">
                    <div class="loading-spinner"></div>
                </div>
            </div>
            
            <div class="preview-container">
                <div class="preview-title">Ending Frame</div>
                <img id="endingPngPreview" class="preview-image">
                <div class="loading" id="loading4">
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>
        
        <div class="animation-preview-section">
            <h2>Animation Preview</h2>
            <div class="animation-container">
                <img id="animationPreview" class="animation-preview">
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div class="frame-info" id="frameInfo">Frame 0/0</div>
                <div class="loading" id="animationLoading">
                    <div class="loading-spinner"></div>
                </div>
            </div>
            <div class="animation-controls">
                <button class="animation-button" id="playButton" disabled>Play Animation</button>
                <button class="animation-button" id="pauseButton" disabled>Pause</button>
                <button class="animation-button" id="loopToggleButton" disabled>Loop: On</button>
            </div>
        </div>
    </div>

    <!-- Canvas for offscreen processing -->
    <div style="display: none;">
        <canvas id="sourceCanvas1"></canvas>
        <canvas id="sourceCanvas2"></canvas>
        <canvas id="processingCanvas"></canvas>
        <canvas id="tempCanvas"></canvas>
    </div>

    <script>
        // Cache DOM elements
        const pngFile1Input = document.getElementById('pngFile1');
        const pngFile2Input = document.getElementById('pngFile2');
        const uploadButton1 = document.getElementById('uploadButton1');
        const uploadButton2 = document.getElementById('uploadButton2');
        const fileName1Div = document.getElementById('fileName1');
        const fileName2Div = document.getElementById('fileName2');
        const generateButton = document.getElementById('generateButton');
        const downloadButton = document.getElementById('downloadButton');
        const startingPngPreview = document.getElementById('startingPngPreview');
        const endingPngPreview = document.getElementById('endingPngPreview');
        const inBetween1Preview = document.getElementById('inBetween1Preview');
        const inBetween2Preview = document.getElementById('inBetween2Preview');
        const interpolationSlider = document.getElementById('interpolationSlider');
        const frameNumberInput = document.getElementById('frameNumberInput');
        const statusMessage = document.getElementById('statusMessage');
        const methodOptions = document.querySelectorAll('.method-option');
        const methodInfo = document.getElementById('methodInfo');
        const morphologicalOptions = document.getElementById('morphologicalOptions');
        const colorHarmonizeOptions = document.getElementById('colorHarmonizeOptions');
        const edgeIntensity = document.getElementById('edgeIntensity');
        const edgeIntensityValue = document.getElementById('edgeIntensityValue');
        const morphStrength = document.getElementById('morphStrength');
        const morphStrengthValue = document.getElementById('morphStrengthValue');
        const morphQuality = document.getElementById('morphQuality');
        const colorShiftIntensity = document.getElementById('colorShiftIntensity');
        const colorShiftValue = document.getElementById('colorShiftValue');
        const saturationLevel = document.getElementById('saturationLevel');
        const saturationValue = document.getElementById('saturationValue');
        const preserveLuma = document.getElementById('preserveLuma');
        const preserveLumaValue = document.getElementById('preserveLumaValue');
        const paletteMethod = document.getElementById('paletteMethod');
        const startPalette = document.getElementById('startPalette');
        const endPalette = document.getElementById('endPalette');
        const animationPreview = document.getElementById('animationPreview');
        const playButton = document.getElementById('playButton');
        const pauseButton = document.getElementById('pauseButton');
        const loopToggleButton = document.getElementById('loopToggleButton');
        const fpsInput = document.getElementById('fpsInput');
        const progressBar = document.getElementById('progressBar');
        const frameInfo = document.getElementById('frameInfo');
        const easingFunction = document.getElementById('easingFunction');
        const easingVisualization = document.getElementById('easingVisualization');
        const easingCurve = document.getElementById('easingCurve');
        const easingPoint = document.getElementById('easingPoint');
        const loadingElements = document.querySelectorAll('.loading');

        // Canvas elements for processing
        const sourceCanvas1 = document.getElementById('sourceCanvas1');
        const sourceCanvas2 = document.getElementById('sourceCanvas2');
        const processingCanvas = document.getElementById('processingCanvas');
        const tempCanvas = document.getElementById('tempCanvas');
        const sourceCtx1 = sourceCanvas1.getContext('2d', { willReadFrequently: true });
        const sourceCtx2 = sourceCanvas2.getContext('2d', { willReadFrequently: true });
        const processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

        // Method descriptions
        const methodDescriptions = {
            'crossfade': 'Crossfade: Simple opacity blending between frames. Good for smooth transitions.',
            'pixelmotion': 'Pixel Motion: Simulates movement of pixels between frames. Good for objects that change position.',
            'morphological': 'Morphological: Advanced shape-based transformation that morphs objects from one form to another.',
            'colorharmonize': 'Color Harmonize: Transforms color palettes between images while maintaining structure. Great for style transitions.',
            'dissolve': 'Dissolve: Film-like dissolve transition with noise patterns. Creates a disintegration effect.',
            'wipe': 'Directional Wipe: Classic wipe transition revealing the second image gradually from one side.',
            'zoom': 'Zoom Blend: Combines zooming and fading effects for a dynamic transition with depth.'
        };

        // Store image data
        let imageData = {
            first: null,
            second: null,
            inBetweenFrames: [],
            width: 0,
            height: 0
        };

        // Color analysis data
        let colorData = {
            firstPalette: [],
            secondPalette: [],
            firstAvgHsl: { h: 0, s: 0, l: 0 },
            secondAvgHsl: { h: 0, s: 0, l: 0 }
        };

        // Animation state
        let animationState = {
            frames: [],
            currentFrame: 0,
            isPlaying: false,
            animationInterval: null,
            fps: 12,
            isLooping: true
        };

        // Default tweening method
        let currentMethod = 'crossfade';

        // Easing functions
        const easingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            bounce: t => {
                if (t < (1/2.75)) {
                    return 7.5625 * t * t;
                } else if (t < (2/2.75)) {
                    return 7.5625 * (t -= (1.5/2.75)) * t + 0.75;
                } else if (t < (2.5/2.75)) {
                    return 7.5625 * (t -= (2.25/2.75)) * t + 0.9375;
                } else {
                    return 7.5625 * (t -= (2.625/2.75)) * t + 0.984375;
                }
            },
            elastic: t => {
                const p = 0.3;
                return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
            }
        };

        // Event Listeners - File Upload Buttons
        uploadButton1.addEventListener('click', function() {
            pngFile1Input.click();
        });
        
        uploadButton2.addEventListener('click', function() {
            pngFile2Input.click();
        });
        
        // File input change handlers
        pngFile1Input.addEventListener('change', function(event) {
            handleFileUpload(event, true);
        });
        
        pngFile2Input.addEventListener('change', function(event) {
            handleFileUpload(event, false);
        });
        
        // Sync slider and number input
        interpolationSlider.addEventListener('input', function() {
            frameNumberInput.value = this.value;
        });
        
        frameNumberInput.addEventListener('input', function() {
            let value = parseInt(this.value);
            if (isNaN(value) || value < 1) value = 1;
            if (value > 100) value = 100;
            this.value = value;
            interpolationSlider.value = value;
        });
        
        // Method selection
        methodOptions.forEach(option => {
            option.addEventListener('click', function() {
                methodOptions.forEach(opt => opt.classList.remove('selected'));
                this.classList.add('selected');
                currentMethod = this.getAttribute('data-method');
                
                // Update method info
                methodInfo.textContent = methodDescriptions[currentMethod] || '';
                methodInfo.classList.add('visible');
                
                // Show/hide method-specific options
                document.querySelectorAll('.method-specific-options').forEach(el => {
                    el.classList.remove('visible');
                });
                
                if (currentMethod === 'morphological') {
                    morphologicalOptions.classList.add('visible');
                } else if (currentMethod === 'colorharmonize') {
                    colorHarmonizeOptions.classList.add('visible');
                    updateColorPalettes();
                }
            });
        });
        
        // Morphological options
        edgeIntensity.addEventListener('input', function() {
            edgeIntensityValue.textContent = this.value;
        });
        
        morphStrength.addEventListener('input', function() {
            morphStrengthValue.textContent = this.value;
        });
        
        // Color Harmonize options
        colorShiftIntensity.addEventListener('input', function() {
            colorShiftValue.textContent = this.value;
        });
        
        saturationLevel.addEventListener('input', function() {
            saturationValue.textContent = this.value;
        });
        
        preserveLuma.addEventListener('input', function() {
            preserveLumaValue.textContent = this.value;
        });
        
        paletteMethod.addEventListener('change', function() {
            // Method changed - update visualization if needed
            if (imageData.first && imageData.second) {
                updateColorPalettes();
            }
        });
        
        // Easing function selection
        easingFunction.addEventListener('change', updateEasingVisualization);
        
        // Animation controls
        playButton.addEventListener('click', playAnimation);
        pauseButton.addEventListener('click', pauseAnimation);
        loopToggleButton.addEventListener('click', toggleLoop);

        // FPS input
        fpsInput.addEventListener('change', function() {
            let value = parseInt(this.value);
            if (isNaN(value) || value < 1) value = 1;
            if (value > 60) value = 60;
            this.value = value;
            animationState.fps = value;
            
            // If animation is playing, restart it with new FPS
            if (animationState.isPlaying) {
                pauseAnimation();
                playAnimation();
            }
        });
        
        // Generate button
        generateButton.addEventListener('click', generateInBetweenFrames);
        
        // Download button
        downloadButton.addEventListener('click', function() {
            if (!imageData.inBetweenFrames || imageData.inBetweenFrames.length === 0) {
                alert("Please generate frames first before downloading.");
                return;
            }
            
            // Create a timestamp for file names
            const timestamp = new Date().toISOString().replace(/[:\.]/g, '-');
            
            // Download starting frame
            downloadImage(startingPngPreview.src, `frame_00_start_${timestamp}.png`);
            
            // Download in-between frames
            imageData.inBetweenFrames.forEach((frameUrl, index) => {
                const frameNum = String(index + 1).padStart(2, '0');
                downloadImage(frameUrl, `frame_${frameNum}_tween_${timestamp}.png`);
            });
            
            // Download ending frame
            const lastFrameNum = String(imageData.inBetweenFrames.length + 1).padStart(2, '0');
            downloadImage(endingPngPreview.src, `frame_${lastFrameNum}_end_${timestamp}.png`);
            
            statusMessage.textContent = `Downloaded ${imageData.inBetweenFrames.length + 2} frames.`;
        });

        // Helper function to download an image
        function downloadImage(dataUrl, filename) {
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Function to handle file uploads
        function handleFileUpload(event, isFirstFile) {
            const fileInput = event.target;
            if (!fileInput.files || !fileInput.files[0]) {
                return;
            }
            
            const file = fileInput.files[0];
            if (!file.type.match('image/png')) {
                alert('Please select a PNG image.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    if (isFirstFile) {
                        imageData.first = img;
                        startingPngPreview.src = e.target.result;
                        fileName1Div.textContent = file.name;
                        statusMessage.textContent = "Starting PNG loaded successfully!";
                    } else {
                        imageData.second = img;
                        endingPngPreview.src = e.target.result;
                        fileName2Div.textContent = file.name;
                        statusMessage.textContent = "Ending PNG loaded successfully!";
                    }
                    
                    // Enable generate button if both images are loaded
                    if (imageData.first && imageData.second) {
                        generateButton.disabled = false;
                        statusMessage.textContent = "Both PNGs loaded. Ready to generate in-between frames!";
                        
                        // Set up canvas dimensions
                        setupCanvases();
                        
                        // Analyze color data if needed
                        if (currentMethod === 'colorharmonize') {
                            analyzeColorData();
                        }
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Set up canvas dimensions based on uploaded images
        function setupCanvases() {
            imageData.width = Math.max(imageData.first.width, imageData.second.width);
            imageData.height = Math.max(imageData.first.height, imageData.second.height);
            
            // Set canvas dimensions
            sourceCanvas1.width = imageData.width;
            sourceCanvas1.height = imageData.height;
            sourceCanvas2.width = imageData.width;
            sourceCanvas2.height = imageData.height;
            processingCanvas.width = imageData.width;
            processingCanvas.height = imageData.height;
            tempCanvas.width = imageData.width;
            tempCanvas.height = imageData.height;
            
            // Draw images to source canvases
            sourceCtx1.clearRect(0, 0, imageData.width, imageData.height);
            sourceCtx2.clearRect(0, 0, imageData.width, imageData.height);
            
            // Draw first image centered
            const x1 = (imageData.width - imageData.first.width) / 2;
            const y1 = (imageData.height - imageData.first.height) / 2;
            sourceCtx1.drawImage(imageData.first, x1, y1);
            
            // Draw second image centered
            const x2 = (imageData.width - imageData.second.width) / 2;
            const y2 = (imageData.height - imageData.second.height) / 2;
            sourceCtx2.drawImage(imageData.second, x2, y2);
        }

        // Function to show loading spinner
        function showLoading(show) {
            loadingElements.forEach(element => {
                element.style.display = show ? 'flex' : 'none';
            });
        }

        // Analyze color data from source images
        function analyzeColorData() {
            // Get pixel data
            const imageData1 = sourceCtx1.getImageData(0, 0, imageData.width, imageData.height);
            const imageData2 = sourceCtx2.getImageData(0, 0, imageData.width, imageData.height);
            
            // Extract color palettes
            colorData.firstPalette = extractDominantColors(imageData1, 5);
            colorData.secondPalette = extractDominantColors(imageData2, 5);
            
            // Calculate average HSL values
            colorData.firstAvgHsl = calculateAverageHsl(imageData1);
            colorData.secondAvgHsl = calculateAverageHsl(imageData2);
            
            // Update UI
            updateColorPalettes();
        }

        // Extract dominant colors from image data
        function extractDominantColors(imageData, colorCount) {
            // Simple color quantization approach
            const pixels = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            // Sample pixels (for performance, don't use every pixel)
            const pixelCount = width * height;
            const sampleRate = Math.max(1, Math.floor(pixelCount / 10000));
            
            // Color frequency map
            const colorMap = new Map();
            
            for (let i = 0; i < pixels.length; i += 4 * sampleRate) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                const a = pixels[i + 3];
                
                // Skip transparent pixels
                if (a < 128) continue;
                
                // Quantize colors to reduce the number of unique colors
                const qr = Math.floor(r / 16) * 16;
                const qg = Math.floor(g / 16) * 16;
                const qb = Math.floor(b / 16) * 16;
                
                const colorKey = `${qr},${qg},${qb}`;
                
                if (colorMap.has(colorKey)) {
                    colorMap.set(colorKey, colorMap.get(colorKey) + 1);
                } else {
                    colorMap.set(colorKey, 1);
                }
            }
            
            // Sort colors by frequency
            const sortedColors = [...colorMap.entries()]
                .sort((a, b) => b[1] - a[1])
                .slice(0, colorCount)
                .map(entry => {
                    const [r, g, b] = entry[0].split(',').map(Number);
                    return { r, g, b };
                });
            
            return sortedColors;
        }

        // Calculate average HSL values for an image
        function calculateAverageHsl(imageData) {
            const pixels = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            let totalH = 0, totalS = 0, totalL = 0;
            let count = 0;
            
            // Sample pixels
            const sampleRate = Math.max(1, Math.floor(width * height / 10000));
            
            for (let i = 0; i < pixels.length; i += 4 * sampleRate) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                const a = pixels[i + 3];
                
                // Skip transparent pixels
                if (a < 128) continue;
                
                // Convert to HSL
                const hsl = rgbToHsl(r, g, b);
                
                totalH += hsl.h;
                totalS += hsl.s;
                totalL += hsl.l;
                count++;
            }
            
            // Calculate averages
            return {
                h: count > 0 ? totalH / count : 0,
                s: count > 0 ? totalS / count : 0,
                l: count > 0 ? totalL / count : 0
            };
        }

        // Update color palette UI
        function updateColorPalettes() {
            if (!colorData.firstPalette.length || !colorData.secondPalette.length) {
                return;
            }
            
            // Clear palette displays
            startPalette.innerHTML = '';
            endPalette.innerHTML = '';
            
            // Add colors to palettes
            colorData.firstPalette.forEach(color => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'palette-color';
                colorDiv.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
                startPalette.appendChild(colorDiv);
            });
            
            colorData.secondPalette.forEach(color => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'palette-color';
                colorDiv.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
                endPalette.appendChild(colorDiv);
            });
        }

        // Function to generate in-between frames
        function generateInBetweenFrames() {
            if (!imageData.first || !imageData.second) {
                statusMessage.textContent = "Please upload both PNG files first.";
                return;
            }
            
            const numFrames = parseInt(frameNumberInput.value);
            statusMessage.textContent = `Generating ${numFrames} in-between frames using ${currentMethod} method...`;
            
            // Show loading indicators
            showLoading(true);
            
            // Reset previous frames
            imageData.inBetweenFrames = [];
            
            // Use setTimeout to keep UI responsive during processing
            setTimeout(() => {
                // Create frames based on the selected method and easing function
                try {
                    // For color harmonize, ensure color data is analyzed
                    if (currentMethod === 'colorharmonize' && 
                        (!colorData.firstPalette.length || !colorData.secondPalette.length)) {
                        analyzeColorData();
                    }
                    
                    for (let i = 0; i < numFrames; i++) {
                        // Calculate raw ratio for this frame (0 to 1)
                        const rawRatio = (i + 1) / (numFrames + 1);
                        
                        // Apply selected easing function
                        const easing = easingFunctions[easingFunction.value] || easingFunctions.linear;
                        const ratio = easing(rawRatio);
                        
                        // Generate the frame based on the selected method
                        processingCtx.clearRect(0, 0, imageData.width, imageData.height);
                        
                        let frameDataUrl;
                        switch (currentMethod) {
                            case 'crossfade':
                                frameDataUrl = generateCrossfadeFrame(ratio);
                                break;
                            case 'pixelmotion':
                                frameDataUrl = generatePixelMotionFrame(ratio);
                                break;
                            case 'morphological':
                                frameDataUrl = generateMorphologicalFrame(ratio);
                                break;
                            case 'colorharmonize':
                                frameDataUrl = generateColorHarmonizeFrame(ratio);
                                break;
                            case 'dissolve':
                                frameDataUrl = generateDissolveFrame(ratio);
                                break;
                            case 'wipe':
                                frameDataUrl = generateWipeFrame(ratio);
                                break;
                            case 'zoom':
                                frameDataUrl = generateZoomFrame(ratio);
                                break;
                            default:
                                frameDataUrl = generateCrossfadeFrame(ratio);
                        }
                        
                        // Store the frame
                        imageData.inBetweenFrames.push(frameDataUrl);
                    }
                    
                    // Update the preview images (if we have enough frames)
                    if (imageData.inBetweenFrames.length >= 2) {
                        // For first preview, pick a frame from the first quarter
                        const previewIndex1 = Math.min(Math.floor(numFrames * 0.25), numFrames - 1);
                        inBetween1Preview.src = imageData.inBetweenFrames[previewIndex1];
                        
                        // For second preview, pick a frame from the third quarter
                        const previewIndex2 = Math.min(Math.floor(numFrames * 0.75), numFrames - 1);
                        inBetween2Preview.src = imageData.inBetweenFrames[previewIndex2];
                    } else if (imageData.inBetweenFrames.length === 1) {
                        // If we only have one frame, use it for both previews
                        inBetween1Preview.src = imageData.inBetweenFrames[0];
                        inBetween2Preview.src = imageData.inBetweenFrames[0];
                    }
                    
                    // Enable animation controls
                    playButton.disabled = false;
                    pauseButton.disabled = false;
                    loopToggleButton.disabled = false;
                    downloadButton.disabled = false;
                    
                    // Set up animation frames
                    setupAnimation();
                    
                    statusMessage.textContent = `Generated ${numFrames} in-between frames using ${currentMethod} method with ${easingFunction.value} easing.`;
                } catch (error) {
                    console.error("Error generating frames:", error);
                    statusMessage.textContent = `Error generating frames: ${error.message}`;
                } finally {
                    // Hide loading indicators
                    showLoading(false);
                }
            }, 100);
        }

        // Generate a crossfade frame
        function generateCrossfadeFrame(ratio) {
            // Draw first image with decreasing opacity
            processingCtx.globalAlpha = 1 - ratio;
            processingCtx.drawImage(sourceCanvas1, 0, 0);
            
            // Draw second image with increasing opacity
            processingCtx.globalAlpha = ratio;
            processingCtx.drawImage(sourceCanvas2, 0, 0);
            
            // Reset alpha
            processingCtx.globalAlpha = 1.0;
            
            return processingCanvas.toDataURL('image/png');
        }

        // Generate a pixel motion frame
        function generatePixelMotionFrame(ratio) {
            // Get pixel data from both images
            const imageData1 = sourceCtx1.getImageData(0, 0, imageData.width, imageData.height);
            const imageData2 = sourceCtx2.getImageData(0, 0, imageData.width, imageData.height);
            const resultData = processingCtx.createImageData(imageData.width, imageData.height);
            
            const width = imageData.width;
            const height = imageData.height;
            
            // Simple pixel motion - interpolate pixel positions
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Calculate displacement based on pixel differences and patterns
                    // This is a simplified approach to simulate pixel motion
                    const displacementX = Math.sin(x / 20 + y / 30) * 5 * ratio;
                    const displacementY = Math.cos(y / 20 + x / 30) * 5 * ratio;
                    
                    // Calculate source and destination positions
                    const sourceX = Math.floor(x - displacementX * (1 - ratio));
                    const sourceY = Math.floor(y - displacementY * (1 - ratio));
                    const destX = Math.floor(x + displacementX * ratio);
                    const destY = Math.floor(y + displacementY * ratio);
                    
                    // Ensure we're within image bounds
                    const validSource = sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height;
                    const validDest = destX >= 0 && destX < width && destY >= 0 && destY < height;
                    
                    // Current pixel index
                    const pixelIndex = (y * width + x) * 4;
                    
                    if (validSource && validDest) {
                        // Source and destination pixel indices
                        const sourceIndex = (sourceY * width + sourceX) * 4;
                        const destIndex = (destY * width + destX) * 4;
                        
                        // Calculate blended color values
                        resultData.data[pixelIndex] = Math.round(imageData1.data[sourceIndex] * (1 - ratio) + imageData2.data[destIndex] * ratio);
                        resultData.data[pixelIndex + 1] = Math.round(imageData1.data[sourceIndex + 1] * (1 - ratio) + imageData2.data[destIndex + 1] * ratio);
                        resultData.data[pixelIndex + 2] = Math.round(imageData1.data[sourceIndex + 2] * (1 - ratio) + imageData2.data[destIndex + 2] * ratio);
                        resultData.data[pixelIndex + 3] = 255; // Full opacity
                    } else {
                        // Fallback to simple crossfade for pixels outside bounds
                        resultData.data[pixelIndex] = Math.round(imageData1.data[pixelIndex] * (1 - ratio) + imageData2.data[pixelIndex] * ratio);
                        resultData.data[pixelIndex + 1] = Math.round(imageData1.data[pixelIndex + 1] * (1 - ratio) + imageData2.data[pixelIndex + 1] * ratio);
                        resultData.data[pixelIndex + 2] = Math.round(imageData1.data[pixelIndex + 2] * (1 - ratio) + imageData2.data[pixelIndex + 2] * ratio);
                        resultData.data[pixelIndex + 3] = 255; // Full opacity
                    }
                }
            }
            
            // Put the resulting image data on the canvas
            processingCtx.putImageData(resultData, 0, 0);
            
            return processingCanvas.toDataURL('image/png');
        }

        // Generate a morphological frame
        function generateMorphologicalFrame(ratio) {
            // Get parameters
            const edgeWeight = parseInt(edgeIntensity.value) / 100;
            const strength = parseInt(morphStrength.value) / 100;
            const quality = morphQuality.value;
            
            // Quality settings
            let scaleFactor = 1.0;
            let blurRadius = 1;
            switch (quality) {
                case 'fast':
                    scaleFactor = 0.5;
                    blurRadius = 1;
                    break;
                case 'medium':
                    scaleFactor = 0.75;
                    blurRadius = 2;
                    break;
                case 'high':
                    scaleFactor = 1.0;
                    blurRadius = 3;
                    break;
            }
            
            // Temporary canvases for edge detection
            const edgeCanvas1 = document.createElement('canvas');
            const edgeCanvas2 = document.createElement('canvas');
            
            const width = Math.floor(imageData.width * scaleFactor);
            const height = Math.floor(imageData.height * scaleFactor);
            
            edgeCanvas1.width = width;
            edgeCanvas1.height = height;
            edgeCanvas2.width = width;
            edgeCanvas2.height = height;
            
            const edgeCtx1 = edgeCanvas1.getContext('2d');
            const edgeCtx2 = edgeCanvas2.getContext('2d');
            
            // Draw scaled images to edge detection canvases
            edgeCtx1.drawImage(sourceCanvas1, 0, 0, width, height);
            edgeCtx2.drawImage(sourceCanvas2, 0, 0, width, height);
            
            // Get image data for edge detection
            const imgData1 = edgeCtx1.getImageData(0, 0, width, height);
            const imgData2 = edgeCtx2.getImageData(0, 0, width, height);
            
            // Detect edges in both images
            const edges1 = detectEdges(imgData1, blurRadius);
            const edges2 = detectEdges(imgData2, blurRadius);
            
            // Create flow field for morphing
            const flowField = createFlowField(edges1, edges2, width, height, strength);
            
            // Create result canvas at original size
            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = imageData.width;
            resultCanvas.height = imageData.height;
            const resultCtx = resultCanvas.getContext('2d');
            
            // Draw morphed image based on flow field
            resultCtx.clearRect(0, 0, imageData.width, imageData.height);
            
            // Draw first image
            resultCtx.globalAlpha = 1.0;
            resultCtx.drawImage(sourceCanvas1, 0, 0);
            
            // Apply morphological transformation via displacement map
            const imageData1Full = sourceCtx1.getImageData(0, 0, imageData.width, imageData.height);
            const imageData2Full = sourceCtx2.getImageData(0, 0, imageData.width, imageData.height);
            const resultData = resultCtx.getImageData(0, 0, imageData.width, imageData.height);
            
            // Apply flow field to create morphed image
            for (let y = 0; y < imageData.height; y++) {
                for (let x = 0; x < imageData.width; x++) {
                    // Scale to flow field coordinates
                    const flowX = Math.floor(x * scaleFactor);
                    const flowY = Math.floor(y * scaleFactor);
                    
                    if (flowX < width && flowY < height) {
                        // Get displacement from flow field
                        const fieldIndex = (flowY * width + flowX) * 2;
                        const dx = flowField[fieldIndex] * ratio * imageData.width * strength;
                        const dy = flowField[fieldIndex + 1] * ratio * imageData.height * strength;
                        
                        // Calculate source and target positions
                        const sourceX = Math.max(0, Math.min(imageData.width - 1, Math.round(x - dx * (1 - ratio))));
                        const sourceY = Math.max(0, Math.min(imageData.height - 1, Math.round(y - dy * (1 - ratio))));
                        const targetX = Math.max(0, Math.min(imageData.width - 1, Math.round(x + dx * ratio)));
                        const targetY = Math.max(0, Math.min(imageData.height - 1, Math.round(y + dy * ratio)));
                        
                        // Get pixel indices
                        const currentIdx = (y * imageData.width + x) * 4;
                        const sourceIdx = (sourceY * imageData.width + sourceX) * 4;
                        const targetIdx = (targetY * imageData.width + targetX) * 4;
                        
                        // Get edge weights
                        const edgeX = Math.floor(x * scaleFactor);
                        const edgeY = Math.floor(y * scaleFactor);
                        const edgeIdx = edgeY * width + edgeX;
                        const edgeWeight1 = edges1[edgeIdx] * edgeWeight;
                        const edgeWeight2 = edges2[edgeIdx] * edgeWeight;
                        
                        // Calculate blending ratio with edge enhancement
                        const blendingRatio = ratio + (edgeWeight1 * (1 - ratio) + edgeWeight2 * ratio) * 0.3;
                        
                        // Blend colors
                        resultData.data[currentIdx] = Math.round(imageData1Full.data[sourceIdx] * (1 - blendingRatio) + imageData2Full.data[targetIdx] * blendingRatio);
                        resultData.data[currentIdx + 1] = Math.round(imageData1Full.data[sourceIdx + 1] * (1 - blendingRatio) + imageData2Full.data[targetIdx + 1] * blendingRatio);
                        resultData.data[currentIdx + 2] = Math.round(imageData1Full.data[sourceIdx + 2] * (1 - blendingRatio) + imageData2Full.data[targetIdx + 2] * blendingRatio);
                        resultData.data[currentIdx + 3] = 255;
                    }
                }
            }
            
            // Put result back on canvas
            resultCtx.putImageData(resultData, 0, 0);
            
            // Draw to processing canvas
            processingCtx.clearRect(0, 0, imageData.width, imageData.height);
            processingCtx.drawImage(resultCanvas, 0, 0);
            
            return processingCanvas.toDataURL('image/png');
        }

        // Generate a color harmonize frame
        function generateColorHarmonizeFrame(ratio) {
            // Get parameters
            const colorShift = parseInt(colorShiftIntensity.value) / 100;
            const saturationMultiplier = parseInt(saturationLevel.value) / 100;
            const preserveLumaAmount = parseInt(preserveLuma.value) / 100;
            const method = paletteMethod.value;
            
            // Get pixel data from both images
            const src1Data = sourceCtx1.getImageData(0, 0, imageData.width, imageData.height);
            const src2Data = sourceCtx2.getImageData(0, 0, imageData.width, imageData.height);
            const resultData = processingCtx.createImageData(imageData.width, imageData.height);
            
            // Process each pixel
            for (let i = 0; i < src1Data.data.length; i += 4) {
                // Get RGB values from source images
                const r1 = src1Data.data[i];
                const g1 = src1Data.data[i + 1];
                const b1 = src1Data.data[i + 2];
                const a1 = src1Data.data[i + 3];
                
                const r2 = src2Data.data[i];
                const g2 = src2Data.data[i + 1];
                const b2 = src2Data.data[i + 2];
                const a2 = src2Data.data[i + 3];
                
                // Skip fully transparent pixels
                if (a1 === 0 && a2 === 0) {
                    resultData.data[i + 3] = 0;
                    continue;
                }
                
                // Convert to HSL for better color manipulation
                const hsl1 = rgbToHsl(r1, g1, b1);
                const hsl2 = rgbToHsl(r2, g2, b2);
                
                let resultHsl;
                
                // Different palette transformation methods
                switch (method) {
                    case 'dominant':
                        // Transform based on dominant colors
                        resultHsl = transformColorWithDominant(hsl1, ratio, colorShift);
                        break;
                        
                    case 'average':
                        // Transform based on average color shift
                        resultHsl = transformColorWithAverage(hsl1, hsl2, ratio, colorShift);
                        break;
                        
                    case 'hue':
                        // Simple hue rotation
                        resultHsl = {
                            h: interpolateHue(hsl1.h, hsl2.h, ratio),
                            s: hsl1.s * (1 - ratio) + hsl2.s * ratio * saturationMultiplier,
                            l: preserveLumaAmount * hsl1.l + (1 - preserveLumaAmount) * (hsl1.l * (1 - ratio) + hsl2.l * ratio)
                        };
                        break;
                        
                    default:
                        // Default to simple HSL interpolation
                        resultHsl = {
                            h: interpolateHue(hsl1.h, hsl2.h, ratio),
                            s: hsl1.s * (1 - ratio) + hsl2.s * ratio * saturationMultiplier,
                            l: hsl1.l * (1 - ratio) + hsl2.l * ratio
                        };
                }
                
                // Apply saturation multiplier
                resultHsl.s *= saturationMultiplier;
                
                // Clamp values
                resultHsl.s = Math.min(1, Math.max(0, resultHsl.s));
                resultHsl.l = Math.min(1, Math.max(0, resultHsl.l));
                
                // Convert back to RGB
                const resultRgb = hslToRgb(resultHsl.h, resultHsl.s, resultHsl.l);
                
                // Set result pixel
                resultData.data[i] = resultRgb.r;
                resultData.data[i + 1] = resultRgb.g;
                resultData.data[i + 2] = resultRgb.b;
                resultData.data[i + 3] = Math.max(a1, a2); // Keep highest alpha
            }
            
            // Put the result on canvas
            processingCtx.putImageData(resultData, 0, 0);
            
            return processingCanvas.toDataURL('image/png');
        }
        
        // Transform color using dominant color palettes
        function transformColorWithDominant(hsl, ratio, colorShift) {
            // Find closest colors in both palettes
            let closestColor1 = findClosestColorInPalette(hsl, colorData.firstPalette);
            let closestColor2 = findClosestColorInPalette(hsl, colorData.secondPalette);
            
            // Convert to HSL
            const closestHsl1 = rgbToHsl(closestColor1.r, closestColor1.g, closestColor1.b);
            const closestHsl2 = rgbToHsl(closestColor2.r, closestColor2.g, closestColor2.b);
            
            // Calculate shift amount
            const hueDiff = calculateHueDifference(closestHsl1.h, closestHsl2.h);
            const satDiff = closestHsl2.s - closestHsl1.s;
            
            // Apply color shift
            const newHsl = {
                h: (hsl.h + hueDiff * ratio * colorShift) % 1.0,
                s: Math.max(0, Math.min(1, hsl.s + satDiff * ratio * colorShift)),
                l: hsl.l
            };
            
            return newHsl;
        }
        
        // Transform color using average color shift
        function transformColorWithAverage(hsl1, hsl2, ratio, colorShift) {
            // Calculate global color shifts
            const globalHueDiff = calculateHueDifference(colorData.firstAvgHsl.h, colorData.secondAvgHsl.h);
            const globalSatDiff = colorData.secondAvgHsl.s - colorData.firstAvgHsl.s;
            
            // Apply global shift to first color
            const shiftedHsl1 = {
                h: (hsl1.h + globalHueDiff * ratio * colorShift) % 1.0,
                s: Math.max(0, Math.min(1, hsl1.s + globalSatDiff * ratio * colorShift)),
                l: hsl1.l
            };
            
            // Then interpolate between the shifted color and the second color
            return {
                h: interpolateHue(shiftedHsl1.h, hsl2.h, ratio),
                s: shiftedHsl1.s * (1 - ratio) + hsl2.s * ratio,
                l: shiftedHsl1.l * (1 - ratio) + hsl2.l * ratio
            };
        }
        
        // Find closest color in palette to given HSL color
        function findClosestColorInPalette(hsl, palette) {
            let closestColor = palette[0];
            let minDistance = Number.MAX_VALUE;
            
            palette.forEach(color => {
                const colorHsl = rgbToHsl(color.r, color.g, color.b);
                const distance = calculateColorDistance(hsl, colorHsl);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            });
            
            return closestColor;
        }
        
        // Calculate perceptual distance between two HSL colors
        function calculateColorDistance(hsl1, hsl2) {
            const hueDiff = calculateHueDifference(hsl1.h, hsl2.h);
            const satDiff = hsl1.s - hsl2.s;
            const lightDiff = hsl1.l - hsl2.l;
            
            // Weight hue differences less for very low saturation colors
            const hueWeight = (hsl1.s + hsl2.s) / 2;
            
            return Math.sqrt(
                (hueDiff * hueWeight) * (hueDiff * hueWeight) * 4 + 
                satDiff * satDiff + 
                lightDiff * lightDiff
            );
        }
        
        // Calculate shortest difference between two hue values
        function calculateHueDifference(h1, h2) {
            const diff = Math.abs(h1 - h2);
            return diff > 0.5 ? 1 - diff : diff;
        }
        
        // Interpolate hue values taking the shortest path around the color wheel
        function interpolateHue(h1, h2, ratio) {
            // Find the shortest path around the color wheel
            let diff = h2 - h1;
            
            if (Math.abs(diff) > 0.5) {
                // Go the other way around the circle
                if (diff > 0) {
                    h1 += 1;
                } else {
                    h2 += 1;
                }
            }
            
            // Interpolate and ensure result is between 0-1
            let result = h1 + (h2 - h1) * ratio;
            return ((result % 1) + 1) % 1; // Ensure result is between 0-1
        }

        // Create a flow field for morphological transformation
        function createFlowField(edges1, edges2, width, height, strength) {
            // Create flow field array (x,y displacement for each pixel)
            const flowField = new Array(width * height * 2).fill(0);
            
            // Simple approach: use edge differences to guide the flow
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    // Calculate edge gradients
                    const gradX1 = (edges1[idx + 1] - edges1[idx - 1]) / 2;
                    const gradY1 = (edges1[idx + width] - edges1[idx - width]) / 2;
                    const gradX2 = (edges2[idx + 1] - edges2[idx - 1]) / 2;
                    const gradY2 = (edges2[idx + width] - edges2[idx - width]) / 2;
                    
                    // Calculate flow direction based on edge differences
                    const flowIdx = idx * 2;
                    flowField[flowIdx] = (gradX2 - gradX1) * strength;
                    flowField[flowIdx + 1] = (gradY2 - gradY1) * strength;
                    
                    // Limit maximum displacement
                    const magnitude = Math.sqrt(flowField[flowIdx] * flowField[flowIdx] + flowField[flowIdx + 1] * flowField[flowIdx + 1]);
                    if (magnitude > 0.2) {
                        flowField[flowIdx] = (flowField[flowIdx] / magnitude) * 0.2;
                        flowField[flowIdx + 1] = (flowField[flowIdx + 1] / magnitude) * 0.2;
                    }
                }
            }
            
            // Smooth the flow field
            const smoothedFlow = smoothFlowField(flowField, width, height);
            
            return smoothedFlow;
        }

        // Smooth the flow field to prevent artifacts
        function smoothFlowField(flowField, width, height) {
            const smoothed = new Array(flowField.length).fill(0);
            
            // Simple box blur
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 2;
                    
                    // Average with neighbors
                    let sumX = 0, sumY = 0, count = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const neighborIdx = ((y + dy) * width + (x + dx)) * 2;
                            sumX += flowField[neighborIdx];
                            sumY += flowField[neighborIdx + 1];
                            count++;
                        }
                    }
                    
                    smoothed[idx] = sumX / count;
                    smoothed[idx + 1] = sumY / count;
                }
            }
            
            return smoothed;
        }

        // Detect edges in an image (simplified Sobel operator)
        function detectEdges(imageData, blurRadius = 1) {
            const width = imageData.width;
            const height = imageData.height;
            const pixels = imageData.data;
            
            // Convert to grayscale and blur first
            const grayscale = new Array(width * height);
            
            // Convert to grayscale
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    grayscale[y * width + x] = (pixels[idx] * 0.3 + pixels[idx + 1] * 0.59 + pixels[idx + 2] * 0.11) / 255;
                }
            }
            
            // Apply Gaussian blur to reduce noise
            const blurred = blurGrayscale(grayscale, width, height, blurRadius);
            
            // Apply Sobel operator for edge detection
            const edges = new Array(width * height).fill(0);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    // Horizontal Sobel
                    const gx = 
                        -1 * blurred[(y-1) * width + (x-1)] +
                        -2 * blurred[y * width + (x-1)] +
                        -1 * blurred[(y+1) * width + (x-1)] +
                        1 * blurred[(y-1) * width + (x+1)] +
                        2 * blurred[y * width + (x+1)] +
                        1 * blurred[(y+1) * width + (x+1)];
                    
                    // Vertical Sobel
                    const gy = 
                        -1 * blurred[(y-1) * width + (x-1)] +
                        -2 * blurred[(y-1) * width + x] +
                        -1 * blurred[(y-1) * width + (x+1)] +
                        1 * blurred[(y+1) * width + (x-1)] +
                        2 * blurred[(y+1) * width + x] +
                        1 * blurred[(y+1) * width + (x+1)];
                    
                    // Edge magnitude (normalized)
                    edges[y * width + x] = Math.min(1.0, Math.sqrt(gx*gx + gy*gy));
                }
            }
            
            return edges;
        }

        // Blur grayscale image
        function blurGrayscale(grayscale, width, height, radius) {
            const result = new Array(width * height).fill(0);
            
            // Simple box blur
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    let count = 0;
                    
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                sum += grayscale[ny * width + nx];
                                count++;
                            }
                        }
                    }
                    
                    result[y * width + x] = sum / count;
                }
            }
            
            return result;
        }

        // Generate a dissolve frame
        function generateDissolveFrame(ratio) {
            // Draw first image completely
            processingCtx.drawImage(sourceCanvas1, 0, 0);
            
            // Create a dissolve pattern
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imageData.width;
            tempCanvas.height = imageData.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Fill with random noise
            const noiseData = tempCtx.createImageData(imageData.width, imageData.height);
            for (let i = 0; i < noiseData.data.length; i += 4) {
                const value = Math.random() < ratio ? 255 : 0;
                noiseData.data[i] = value;     // R
                noiseData.data[i + 1] = value; // G
                noiseData.data[i + 2] = value; // B
                noiseData.data[i + 3] = 255;   // A
            }
            tempCtx.putImageData(noiseData, 0, 0);
            
            // Use the dissolve pattern as a mask
            processingCtx.globalCompositeOperation = 'destination-out';
            processingCtx.drawImage(tempCanvas, 0, 0);
            
            // Draw the second image beneath
            processingCtx.globalCompositeOperation = 'destination-over';
            processingCtx.drawImage(sourceCanvas2, 0, 0);
            
            // Reset composite operation
            processingCtx.globalCompositeOperation = 'source-over';
            
            return processingCanvas.toDataURL('image/png');
        }

        // Generate a directional wipe frame
        function generateWipeFrame(ratio) {
            // Draw first image completely
            processingCtx.drawImage(sourceCanvas1, 0, 0);
            
            // Create a gradient for the wipe
            const gradient = processingCtx.createLinearGradient(0, 0, imageData.width, 0);
            gradient.addColorStop(ratio, 'rgba(255,255,255,1)');
            gradient.addColorStop(Math.min(ratio + 0.1, 1), 'rgba(255,255,255,0)');
            
            // Fill right portion with the gradient
            processingCtx.globalCompositeOperation = 'destination-out';
            processingCtx.fillStyle = 'white';
            processingCtx.fillRect(0, 0, imageData.width * ratio, imageData.height);
            
            // Create soft edge
            processingCtx.fillStyle = gradient;
            processingCtx.fillRect(imageData.width * ratio - 1, 0, imageData.width * 0.1 + 2, imageData.height);
            
            // Draw the second image beneath
            processingCtx.globalCompositeOperation = 'destination-over';
            processingCtx.drawImage(sourceCanvas2, 0, 0);
            
            // Reset composite operation
            processingCtx.globalCompositeOperation = 'source-over';
            
            return processingCanvas.toDataURL('image/png');
        }

        // Generate a zoom blend frame
        function generateZoomFrame(ratio) {
            // Calculate zoom factors
            const zoomFactor1 = 1.0 + 0.2 * ratio;
            const zoomFactor2 = 1.0 + 0.2 * (1 - ratio);
            
            // Calculate offsets to keep zoomed images centered
            const offsetX1 = (imageData.width - imageData.width * zoomFactor1) / 2;
            const offsetY1 = (imageData.height - imageData.height * zoomFactor1) / 2;
            const offsetX2 = (imageData.width - imageData.width * zoomFactor2) / 2;
            const offsetY2 = (imageData.height - imageData.height * zoomFactor2) / 2;
            
            // Draw first image with zoom out effect and decreasing opacity
            processingCtx.globalAlpha = 1 - ratio;
            processingCtx.drawImage(sourceCanvas1, offsetX1, offsetY1, 
                                   imageData.width * zoomFactor1, imageData.height * zoomFactor1);
            
            // Draw second image with zoom in effect and increasing opacity
            processingCtx.globalAlpha = ratio;
            processingCtx.drawImage(sourceCanvas2, offsetX2, offsetY2, 
                                   imageData.width * zoomFactor2, imageData.height * zoomFactor2);
            
            // Reset alpha
            processingCtx.globalAlpha = 1.0;
            
            return processingCanvas.toDataURL('image/png');
        }

        // RGB to HSL conversion
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            return { h, s, l };
        }
        
        // HSL to RGB conversion
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        // Update easing visualization
        function updateEasingVisualization() {
            const easing = easingFunctions[easingFunction.value] || easingFunctions.linear;
            
            // Show visualization
            easingVisualization.style.display = 'block';
            
            // Draw the curve with animated point
            const width = easingCurve.clientWidth;
            const height = easingCurve.clientHeight;
            
            // Animate the point along the curve
            let t = 0;
            const animate = () => {
                t += 0.01;
                if (t > 1) t = 0;
                
                const y = 1 - easing(t); // Invert Y because 0,0 is top-left
                easingPoint.style.left = `${t * 100}%`;
                easingPoint.style.top = `${y * 100}%`;
                
                if (t < 1) requestAnimationFrame(animate);
            };
            
            animate();
        }

        // Set up animation with all frames
        function setupAnimation() {
            // Create array of all frames in sequence
            animationState.frames = [
                startingPngPreview.src,
                ...imageData.inBetweenFrames,
                endingPngPreview.src
            ];
            
            // Reset animation state
            animationState.currentFrame = 0;
            animationState.isPlaying = false;
            animationState.fps = parseInt(fpsInput.value) || 12;
            
            // Clear any existing animation
            if (animationState.animationInterval) {
                clearInterval(animationState.animationInterval);
                animationState.animationInterval = null;
            }
            
            // Set initial frame
            animationPreview.src = animationState.frames[0];
            updateFrameInfo();
        }

        // Play animation
        function playAnimation() {
            if (animationState.isPlaying) return;
            if (animationState.frames.length <= 1) return;
            
            animationState.isPlaying = true;
            
            // Set up animation interval
            const frameTime = 1000 / animationState.fps;
            animationState.animationInterval = setInterval(() => {
                // Advance to next frame
                animationState.currentFrame++;
                
                // Handle loop or end
                if (animationState.currentFrame >= animationState.frames.length) {
                    if (animationState.isLooping) {
                        animationState.currentFrame = 0;
                    } else {
                        animationState.currentFrame = animationState.frames.length - 1;
                        pauseAnimation();
                        return;
                    }
                }
                
                // Update the preview image
                animationPreview.src = animationState.frames[animationState.currentFrame];
                
                // Update frame info and progress bar
                updateFrameInfo();
            }, frameTime);
        }

        // Pause animation
        function pauseAnimation() {
            if (!animationState.isPlaying) return;
            
            animationState.isPlaying = false;
            
            // Clear animation interval
            if (animationState.animationInterval) {
                clearInterval(animationState.animationInterval);
                animationState.animationInterval = null;
            }
        }

        // Toggle animation looping
        function toggleLoop() {
            animationState.isLooping = !animationState.isLooping;
            loopToggleButton.textContent = `Loop: ${animationState.isLooping ? 'On' : 'Off'}`;
        }

        // Update frame info and progress bar
        function updateFrameInfo() {
            const totalFrames = animationState.frames.length;
            frameInfo.textContent = `Frame ${animationState.currentFrame + 1}/${totalFrames}`;
            
            // Update progress bar
            const progress = (animationState.currentFrame / (totalFrames - 1)) * 100;
            progressBar.style.width = `${progress}%`;
        }

        // Initialize status message and easing visualization
        statusMessage.textContent = "Upload your starting and ending PNG images to begin.";
        updateEasingVisualization();
        
        // Initialize method info
        methodInfo.classList.add('visible');
    </script>
</body>
</html>
