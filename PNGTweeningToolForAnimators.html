<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNG Tweening Tool for Animators</title>
    <style>
        :root {
            --primary-color: #4a6baf;
            --secondary-color: #6d8ad6;
            --background-color: #f5f7ff;
            --accent-color: #ff7e5f;
            --text-color: #333;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        h1, h2, h3 {
            color: var(--primary-color);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--secondary-color);
        }

        .upload-section {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .upload-container {
            flex: 1;
            min-width: 280px;
            padding: 20px;
            border: 2px dashed var(--secondary-color);
            border-radius: var(--border-radius);
            text-align: center;
            transition: all 0.3s ease;
        }

        .upload-container:hover {
            border-color: var(--primary-color);
            background-color: rgba(74, 107, 175, 0.05);
        }

        .upload-label {
            display: block;
            margin-bottom: 15px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .file-input {
            display: none;
        }

        .upload-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .upload-button:hover {
            background-color: var(--secondary-color);
        }

        .preview-section {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        .preview-container {
            flex: 1;
            min-width: 280px;
            height: 280px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            padding: 10px;
            background-color: white;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .preview-title {
            position: absolute;
            top: 5px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--primary-color);
            z-index: 10;
        }

        .preview-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .controls-section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: rgba(74, 107, 175, 0.1);
            border-radius: var(--border-radius);
        }

        .settings-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .settings-column {
            flex: 1;
            min-width: 280px;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .action-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .action-button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }

        .action-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }

        .action-button.download {
            background-color: var(--accent-color);
        }

        .action-button.download:hover {
            background-color: #ff9a82;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .frame-input-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .frame-number-input {
            width: 60px;
            padding: 5px;
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
        }

        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #ddd;
            outline: none;
            border-radius: 4px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        .status-message {
            text-align: center;
            margin-top: 15px;
            color: var(--primary-color);
            font-weight: bold;
        }

        .method-container {
            margin-bottom: 15px;
        }

        .method-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .method-option {
            background-color: white;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .method-option:hover {
            background-color: rgba(74, 107, 175, 0.1);
            transform: translateY(-2px);
        }

        .method-option.selected {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Animation preview styles */
        .animation-preview-section {
            margin-top: 30px;
            margin-bottom: 30px;
        }

        .animation-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            background-color: #f8f8f8;
            position: relative;
        }
        
        .animation-preview {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
        }

        .animation-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .animation-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .animation-button:hover {
            background-color: var(--secondary-color);
        }

        .animation-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .playback-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .playback-label {
            font-weight: bold;
            color: var(--primary-color);
            min-width: 120px;
        }

        .playback-input {
            width: 60px;
            padding: 5px;
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
            text-align: center;
        }

        .playback-select {
            padding: 5px;
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
        }

        .progress-container {
            width: 100%;
            height: 4px;
            background-color: #ddd;
            position: absolute;
            bottom: 0;
            left: 0;
            border-bottom-left-radius: var(--border-radius);
            border-bottom-right-radius: var(--border-radius);
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--accent-color);
            width: 0%;
            transition: width 0.1s linear;
        }

        .frame-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--primary-color);
        }

        /* Easing visualization */
        .easing-viz {
            margin-top: 10px;
            width: 100%;
            height: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            display: none;
        }

        .easing-curve {
            width: 100%;
            height: 100%;
            background-color: #f8f8f8;
            position: relative;
        }

        .easing-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--accent-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PNG Tweening Tool for Animators</h1>
        
        <div class="upload-section">
            <div class="upload-container">
                <label class="upload-label">Starting Frame (PNG)</label>
                <input type="file" id="pngFile1" class="file-input" accept="image/png">
                <button class="upload-button" id="uploadButton1">Upload Starting PNG</button>
                <div id="fileName1" style="margin-top: 10px; font-size: 0.9rem;"></div>
            </div>
            
            <div class="upload-container">
                <label class="upload-label">Ending Frame (PNG)</label>
                <input type="file" id="pngFile2" class="file-input" accept="image/png">
                <button class="upload-button" id="uploadButton2">Upload Ending PNG</button>
                <div id="fileName2" style="margin-top: 10px; font-size: 0.9rem;"></div>
            </div>
        </div>
        
        <div class="controls-section">
            <div class="settings-row">
                <div class="settings-column">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Number of in-between frames:</span>
                            <div class="frame-input-container">
                                <input type="number" id="frameNumberInput" class="frame-number-input" min="1" max="100" value="4">
                            </div>
                        </div>
                        <input type="range" min="1" max="100" value="4" class="slider" id="interpolationSlider">
                    </div>
                    
                    <div class="method-container">
                        <label class="slider-label">Tweening Method:</label>
                        <div class="method-options">
                            <div class="method-option selected" data-method="crossfade">Crossfade</div>
                            <div class="method-option" data-method="pixelmotion">Pixel Motion</div>
                            <div class="method-option" data-method="dissolve">Dissolve</div>
                            <div class="method-option" data-method="wipe">Directional Wipe</div>
                            <div class="method-option" data-method="zoom">Zoom Blend</div>
                        </div>
                    </div>
                </div>
                
                <div class="settings-column">
                    <div class="playback-control">
                        <span class="playback-label">Animation Speed:</span>
                        <input type="number" id="fpsInput" class="playback-input" min="1" max="60" value="12"> fps
                    </div>
                    
                    <div class="playback-control">
                        <span class="playback-label">Easing Function:</span>
                        <select id="easingFunction" class="playback-select">
                            <option value="linear">Linear</option>
                            <option value="easeInQuad">Ease In</option>
                            <option value="easeOutQuad">Ease Out</option>
                            <option value="easeInOutQuad">Ease In/Out</option>
                            <option value="bounce">Bounce</option>
                            <option value="elastic">Elastic</option>
                        </select>
                    </div>
                    
                    <div id="easingVisualization" class="easing-viz">
                        <div class="easing-curve" id="easingCurve">
                            <div class="easing-point" id="easingPoint"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="action-button" id="generateButton" disabled>Generate In-Between Frames</button>
                <button class="action-button download" id="downloadButton" disabled>Download All Frames</button>
            </div>
            
            <div class="status-message" id="statusMessage"></div>
        </div>
        
        <h2>Frame Previews</h2>
        <div class="preview-section">
            <div class="preview-container">
                <div class="preview-title">Starting Frame</div>
                <img id="startingPngPreview" class="preview-image">
            </div>
            
            <div class="preview-container">
                <div class="preview-title">In-Between 1</div>
                <img id="inBetween1Preview" class="preview-image">
            </div>
            
            <div class="preview-container">
                <div class="preview-title">In-Between 2</div>
                <img id="inBetween2Preview" class="preview-image">
            </div>
            
            <div class="preview-container">
                <div class="preview-title">Ending Frame</div>
                <img id="endingPngPreview" class="preview-image">
            </div>
        </div>
        
        <div class="animation-preview-section">
            <h2>Animation Preview</h2>
            <div class="animation-container">
                <img id="animationPreview" class="animation-preview">
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div class="frame-info" id="frameInfo">Frame 0/0</div>
            </div>
            <div class="animation-controls">
                <button class="animation-button" id="playButton" disabled>Play Animation</button>
                <button class="animation-button" id="pauseButton" disabled>Pause</button>
                <button class="animation-button" id="loopToggleButton" disabled>Loop: On</button>
            </div>
        </div>
    </div>

    <!-- Canvas for offscreen processing -->
    <div style="display: none;">
        <canvas id="sourceCanvas1"></canvas>
        <canvas id="sourceCanvas2"></canvas>
        <canvas id="processingCanvas"></canvas>
    </div>

    <script>
        // Cache DOM elements
        const pngFile1Input = document.getElementById('pngFile1');
        const pngFile2Input = document.getElementById('pngFile2');
        const uploadButton1 = document.getElementById('uploadButton1');
        const uploadButton2 = document.getElementById('uploadButton2');
        const fileName1Div = document.getElementById('fileName1');
        const fileName2Div = document.getElementById('fileName2');
        const generateButton = document.getElementById('generateButton');
        const downloadButton = document.getElementById('downloadButton');
        const startingPngPreview = document.getElementById('startingPngPreview');
        const endingPngPreview = document.getElementById('endingPngPreview');
        const inBetween1Preview = document.getElementById('inBetween1Preview');
        const inBetween2Preview = document.getElementById('inBetween2Preview');
        const interpolationSlider = document.getElementById('interpolationSlider');
        const frameNumberInput = document.getElementById('frameNumberInput');
        const statusMessage = document.getElementById('statusMessage');
        const methodOptions = document.querySelectorAll('.method-option');
        const animationPreview = document.getElementById('animationPreview');
        const playButton = document.getElementById('playButton');
        const pauseButton = document.getElementById('pauseButton');
        const loopToggleButton = document.getElementById('loopToggleButton');
        const fpsInput = document.getElementById('fpsInput');
        const progressBar = document.getElementById('progressBar');
        const frameInfo = document.getElementById('frameInfo');
        const easingFunction = document.getElementById('easingFunction');
        const easingVisualization = document.getElementById('easingVisualization');
        const easingCurve = document.getElementById('easingCurve');
        const easingPoint = document.getElementById('easingPoint');

        // Canvas elements for processing
        const sourceCanvas1 = document.getElementById('sourceCanvas1');
        const sourceCanvas2 = document.getElementById('sourceCanvas2');
        const processingCanvas = document.getElementById('processingCanvas');
        const sourceCtx1 = sourceCanvas1.getContext('2d', { willReadFrequently: true });
        const sourceCtx2 = sourceCanvas2.getContext('2d', { willReadFrequently: true });
        const processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });

        // Store image data
        let imageData = {
            first: null,
            second: null,
            inBetweenFrames: [],
            width: 0,
            height: 0
        };

        // Animation state
        let animationState = {
            frames: [],
            currentFrame: 0,
            isPlaying: false,
            animationInterval: null,
            fps: 12,
            isLooping: true
        };

        // Default tweening method
        let currentMethod = 'crossfade';

        // Easing functions
        const easingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            bounce: t => {
                if (t < (1/2.75)) {
                    return 7.5625 * t * t;
                } else if (t < (2/2.75)) {
                    return 7.5625 * (t -= (1.5/2.75)) * t + 0.75;
                } else if (t < (2.5/2.75)) {
                    return 7.5625 * (t -= (2.25/2.75)) * t + 0.9375;
                } else {
                    return 7.5625 * (t -= (2.625/2.75)) * t + 0.984375;
                }
            },
            elastic: t => {
                const p = 0.3;
                return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
            }
        };

        // Event Listeners - File Upload Buttons
        uploadButton1.addEventListener('click', function() {
            pngFile1Input.click();
        });
        
        uploadButton2.addEventListener('click', function() {
            pngFile2Input.click();
        });
        
        // File input change handlers
        pngFile1Input.addEventListener('change', function(event) {
            handleFileUpload(event, true);
        });
        
        pngFile2Input.addEventListener('change', function(event) {
            handleFileUpload(event, false);
        });
        
        // Sync slider and number input
        interpolationSlider.addEventListener('input', function() {
            frameNumberInput.value = this.value;
        });
        
        frameNumberInput.addEventListener('input', function() {
            let value = parseInt(this.value);
            if (isNaN(value) || value < 1) value = 1;
            if (value > 100) value = 100;
            this.value = value;
            interpolationSlider.value = value;
        });
        
        // Method selection
        methodOptions.forEach(option => {
            option.addEventListener('click', function() {
                methodOptions.forEach(opt => opt.classList.remove('selected'));
                this.classList.add('selected');
                currentMethod = this.getAttribute('data-method');
            });
        });
        
        // Easing function selection
        easingFunction.addEventListener('change', updateEasingVisualization);
        
        // Animation controls
        playButton.addEventListener('click', playAnimation);
        pauseButton.addEventListener('click', pauseAnimation);
        loopToggleButton.addEventListener('click', toggleLoop);

        // FPS input
        fpsInput.addEventListener('change', function() {
            let value = parseInt(this.value);
            if (isNaN(value) || value < 1) value = 1;
            if (value > 60) value = 60;
            this.value = value;
            animationState.fps = value;
            
            // If animation is playing, restart it with new FPS
            if (animationState.isPlaying) {
                pauseAnimation();
                playAnimation();
            }
        });
        
        // Generate button
        generateButton.addEventListener('click', generateInBetweenFrames);
        
        // Download button
        downloadButton.addEventListener('click', function() {
            if (!imageData.inBetweenFrames || imageData.inBetweenFrames.length === 0) {
                alert("Please generate frames first before downloading.");
                return;
            }
            
            // Create a timestamp for file names
            const timestamp = new Date().toISOString().replace(/[:\.]/g, '-');
            
            // Download starting frame
            downloadImage(startingPngPreview.src, `frame_00_start_${timestamp}.png`);
            
            // Download in-between frames
            imageData.inBetweenFrames.forEach((frameUrl, index) => {
                const frameNum = String(index + 1).padStart(2, '0');
                downloadImage(frameUrl, `frame_${frameNum}_tween_${timestamp}.png`);
            });
            
            // Download ending frame
            const lastFrameNum = String(imageData.inBetweenFrames.length + 1).padStart(2, '0');
            downloadImage(endingPngPreview.src, `frame_${lastFrameNum}_end_${timestamp}.png`);
            
            statusMessage.textContent = `Downloaded ${imageData.inBetweenFrames.length + 2} frames.`;
        });

        // Helper function to download an image
        function downloadImage(dataUrl, filename) {
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Function to handle file uploads
        function handleFileUpload(event, isFirstFile) {
            const fileInput = event.target;
            if (!fileInput.files || !fileInput.files[0]) {
                return;
            }
            
            const file = fileInput.files[0];
            if (!file.type.match('image/png')) {
                alert('Please select a PNG image.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    if (isFirstFile) {
                        imageData.first = img;
                        startingPngPreview.src = e.target.result;
                        fileName1Div.textContent = file.name;
                        statusMessage.textContent = "Starting PNG loaded successfully!";
                    } else {
                        imageData.second = img;
                        endingPngPreview.src = e.target.result;
                        fileName2Div.textContent = file.name;
                        statusMessage.textContent = "Ending PNG loaded successfully!";
                    }
                    
                    // Enable generate button if both images are loaded
                    if (imageData.first && imageData.second) {
                        generateButton.disabled = false;
                        statusMessage.textContent = "Both PNGs loaded. Ready to generate in-between frames!";
                        
                        // Set up canvas dimensions
                        setupCanvases();
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Set up canvas dimensions based on uploaded images
        function setupCanvases() {
            imageData.width = Math.max(imageData.first.width, imageData.second.width);
            imageData.height = Math.max(imageData.first.height, imageData.second.height);
            
            // Set canvas dimensions
            sourceCanvas1.width = imageData.width;
            sourceCanvas1.height = imageData.height;
            sourceCanvas2.width = imageData.width;
            sourceCanvas2.height = imageData.height;
            processingCanvas.width = imageData.width;
            processingCanvas.height = imageData.height;
            
            // Draw images to source canvases
            sourceCtx1.clearRect(0, 0, imageData.width, imageData.height);
            sourceCtx2.clearRect(0, 0, imageData.width, imageData.height);
            
            // Draw first image centered
            const x1 = (imageData.width - imageData.first.width) / 2;
            const y1 = (imageData.height - imageData.first.height) / 2;
            sourceCtx1.drawImage(imageData.first, x1, y1);
            
            // Draw second image centered
            const x2 = (imageData.width - imageData.second.width) / 2;
            const y2 = (imageData.height - imageData.second.height) / 2;
            sourceCtx2.drawImage(imageData.second, x2, y2);
        }

        // Function to generate in-between frames
        function generateInBetweenFrames() {
            if (!imageData.first || !imageData.second) {
                statusMessage.textContent = "Please upload both PNG files first.";
                return;
            }
            
            const numFrames = parseInt(frameNumberInput.value);
            statusMessage.textContent = `Generating ${numFrames} in-between frames using ${currentMethod} method...`;
            
            // Reset previous frames
            imageData.inBetweenFrames = [];
            
            // Create frames based on the selected method and easing function
            for (let i = 0; i < numFrames; i++) {
                // Calculate raw ratio for this frame (0 to 1)
                const rawRatio = (i + 1) / (numFrames + 1);
                
                // Apply selected easing function
                const easing = easingFunctions[easingFunction.value] || easingFunctions.linear;
                const ratio = easing(rawRatio);
                
                // Generate the frame based on the selected method
                processingCtx.clearRect(0, 0, imageData.width, imageData.height);
                
                let frameDataUrl;
                switch (currentMethod) {
                    case 'crossfade':
                        frameDataUrl = generateCrossfadeFrame(ratio);
                        break;
                    case 'pixelmotion':
                        frameDataUrl = generatePixelMotionFrame(ratio);
                        break;
                    case 'dissolve':
                        frameDataUrl = generateDissolveFrame(ratio);
                        break;
                    case 'wipe':
                        frameDataUrl = generateWipeFrame(ratio);
                        break;
                    case 'zoom':
                        frameDataUrl = generateZoomFrame(ratio);
                        break;
                    default:
                        frameDataUrl = generateCrossfadeFrame(ratio);
                }
                
                // Store the frame
                imageData.inBetweenFrames.push(frameDataUrl);
            }
            
            // Update the preview images (if we have enough frames)
            if (imageData.inBetweenFrames.length >= 2) {
                // For first preview, pick a frame from the first quarter
                const previewIndex1 = Math.min(Math.floor(numFrames * 0.25), numFrames - 1);
                inBetween1Preview.src = imageData.inBetweenFrames[previewIndex1];
                
                // For second preview, pick a frame from the third quarter
                const previewIndex2 = Math.min(Math.floor(numFrames * 0.75), numFrames - 1);
                inBetween2Preview.src = imageData.inBetweenFrames[previewIndex2];
            } else if (imageData.inBetweenFrames.length === 1) {
                // If we only have one frame, use it for both previews
                inBetween1Preview.src = imageData.inBetweenFrames[0];
                inBetween2Preview.src = imageData.inBetweenFrames[0];
            }
            
            // Enable animation controls
            playButton.disabled = false;
            pauseButton.disabled = false;
            loopToggleButton.disabled = false;
            downloadButton.disabled = false;
            
            // Set up animation frames
            setupAnimation();
            
            statusMessage.textContent = `Generated ${numFrames} in-between frames using ${currentMethod} method with ${easingFunction.value} easing.`;
        }

        // Generate a crossfade frame
        function generateCrossfadeFrame(ratio) {
            // Draw first image with decreasing opacity
            processingCtx.globalAlpha = 1 - ratio;
            processingCtx.drawImage(sourceCanvas1, 0, 0);
            
            // Draw second image with increasing opacity
            processingCtx.globalAlpha = ratio;
            processingCtx.drawImage(sourceCanvas2, 0, 0);
            
            // Reset alpha
            processingCtx.globalAlpha = 1.0;
            
            return processingCanvas.toDataURL('image/png');
        }

        // Generate a pixel motion frame
        function generatePixelMotionFrame(ratio) {
            // Get pixel data from both images
            const imageData1 = sourceCtx1.getImageData(0, 0, imageData.width, imageData.height);
            const imageData2 = sourceCtx2.getImageData(0, 0, imageData.width, imageData.height);
            const resultData = processingCtx.createImageData(imageData.width, imageData.height);
            
            const width = imageData.width;
            const height = imageData.height;
            
            // Simple pixel motion - interpolate pixel positions
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Calculate displacement based on pixel differences and patterns
                    // This is a simplified approach to simulate pixel motion
                    const displacementX = Math.sin(x / 20 + y / 30) * 5 * ratio;
                    const displacementY = Math.cos(y / 20 + x / 30) * 5 * ratio;
                    
                    // Calculate source and destination positions
                    const sourceX = Math.floor(x - displacementX * (1 - ratio));
                    const sourceY = Math.floor(y - displacementY * (1 - ratio));
                    const destX = Math.floor(x + displacementX * ratio);
                    const destY = Math.floor(y + displacementY * ratio);
                    
                    // Ensure we're within image bounds
                    const validSource = sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height;
                    const validDest = destX >= 0 && destX < width && destY >= 0 && destY < height;
                    
                    // Current pixel index
                    const pixelIndex = (y * width + x) * 4;
                    
                    if (validSource && validDest) {
                        // Source and destination pixel indices
                        const sourceIndex = (sourceY * width + sourceX) * 4;
                        const destIndex = (destY * width + destX) * 4;
                        
                        // Calculate blended color values
                        resultData.data[pixelIndex] = Math.round(imageData1.data[sourceIndex] * (1 - ratio) + imageData2.data[destIndex] * ratio);
                        resultData.data[pixelIndex + 1] = Math.round(imageData1.data[sourceIndex + 1] * (1 - ratio) + imageData2.data[destIndex + 1] * ratio);
                        resultData.data[pixelIndex + 2] = Math.round(imageData1.data[sourceIndex + 2] * (1 - ratio) + imageData2.data[destIndex + 2] * ratio);
                        resultData.data[pixelIndex + 3] = 255; // Full opacity
                    } else {
                        // Fallback to simple crossfade for pixels outside bounds
                        resultData.data[pixelIndex] = Math.round(imageData1.data[pixelIndex] * (1 - ratio) + imageData2.data[pixelIndex] * ratio);
                        resultData.data[pixelIndex + 1] = Math.round(imageData1.data[pixelIndex + 1] * (1 - ratio) + imageData2.data[pixelIndex + 1] * ratio);
                        resultData.data[pixelIndex + 2] = Math.round(imageData1.data[pixelIndex + 2] * (1 - ratio) + imageData2.data[pixelIndex + 2] * ratio);
                        resultData.data[pixelIndex + 3] = 255; // Full opacity
                    }
                }
            }
            
            // Put the resulting image data on the canvas
            processingCtx.putImageData(resultData, 0, 0);
            
            return processingCanvas.toDataURL('image/png');
        }

        // Generate a dissolve frame
        function generateDissolveFrame(ratio) {
            // Draw first image completely
            processingCtx.drawImage(sourceCanvas1, 0, 0);
            
            // Create a dissolve pattern
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imageData.width;
            tempCanvas.height = imageData.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Fill with random noise
            const noiseData = tempCtx.createImageData(imageData.width, imageData.height);
            for (let i = 0; i < noiseData.data.length; i += 4) {
                const value = Math.random() < ratio ? 255 : 0;
                noiseData.data[i] = value;     // R
                noiseData.data[i + 1] = value; // G
                noiseData.data[i + 2] = value; // B
                noiseData.data[i + 3] = 255;   // A
            }
            tempCtx.putImageData(noiseData, 0, 0);
            
            // Use the dissolve pattern as a mask
            processingCtx.globalCompositeOperation = 'destination-out';
            processingCtx.drawImage(tempCanvas, 0, 0);
            
            // Draw the second image beneath
            processingCtx.globalCompositeOperation = 'destination-over';
            processingCtx.drawImage(sourceCanvas2, 0, 0);
            
            // Reset composite operation
            processingCtx.globalCompositeOperation = 'source-over';
            
            return processingCanvas.toDataURL('image/png');
        }

        // Generate a directional wipe frame
        function generateWipeFrame(ratio) {
            // Draw first image completely
            processingCtx.drawImage(sourceCanvas1, 0, 0);
            
            // Create a gradient for the wipe
            const gradient = processingCtx.createLinearGradient(0, 0, imageData.width, 0);
            gradient.addColorStop(ratio, 'rgba(255,255,255,1)');
            gradient.addColorStop(Math.min(ratio + 0.1, 1), 'rgba(255,255,255,0)');
            
            // Fill right portion with the gradient
            processingCtx.globalCompositeOperation = 'destination-out';
            processingCtx.fillStyle = 'white';
            processingCtx.fillRect(0, 0, imageData.width * ratio, imageData.height);
            
            // Create soft edge
            processingCtx.fillStyle = gradient;
            processingCtx.fillRect(imageData.width * ratio - 1, 0, imageData.width * 0.1 + 2, imageData.height);
            
            // Draw the second image beneath
            processingCtx.globalCompositeOperation = 'destination-over';
            processingCtx.drawImage(sourceCanvas2, 0, 0);
            
            // Reset composite operation
            processingCtx.globalCompositeOperation = 'source-over';
            
            return processingCanvas.toDataURL('image/png');
        }

        // Generate a zoom blend frame
        function generateZoomFrame(ratio) {
            // Calculate zoom factors
            const zoomFactor1 = 1.0 + 0.2 * ratio;
            const zoomFactor2 = 1.0 + 0.2 * (1 - ratio);
            
            // Calculate offsets to keep zoomed images centered
            const offsetX1 = (imageData.width - imageData.width * zoomFactor1) / 2;
            const offsetY1 = (imageData.height - imageData.height * zoomFactor1) / 2;
            const offsetX2 = (imageData.width - imageData.width * zoomFactor2) / 2;
            const offsetY2 = (imageData.height - imageData.height * zoomFactor2) / 2;
            
            // Draw first image with zoom out effect and decreasing opacity
            processingCtx.globalAlpha = 1 - ratio;
            processingCtx.drawImage(sourceCanvas1, offsetX1, offsetY1, 
                                   imageData.width * zoomFactor1, imageData.height * zoomFactor1);
            
            // Draw second image with zoom in effect and increasing opacity
            processingCtx.globalAlpha = ratio;
            processingCtx.drawImage(sourceCanvas2, offsetX2, offsetY2, 
                                   imageData.width * zoomFactor2, imageData.height * zoomFactor2);
            
            // Reset alpha
            processingCtx.globalAlpha = 1.0;
            
            return processingCanvas.toDataURL('image/png');
        }

        // Update easing visualization
        function updateEasingVisualization() {
            const easing = easingFunctions[easingFunction.value] || easingFunctions.linear;
            
            // Show visualization
            easingVisualization.style.display = 'block';
            
            // Draw the curve with animated point
            const width = easingCurve.clientWidth;
            const height = easingCurve.clientHeight;
            
            // Animate the point along the curve
            let t = 0;
            const animate = () => {
                t += 0.01;
                if (t > 1) t = 0;
                
                const y = 1 - easing(t); // Invert Y because 0,0 is top-left
                easingPoint.style.left = `${t * 100}%`;
                easingPoint.style.top = `${y * 100}%`;
                
                if (t < 1) requestAnimationFrame(animate);
            };
            
            animate();
        }

        // Set up animation with all frames
        function setupAnimation() {
            // Create array of all frames in sequence
            animationState.frames = [
                startingPngPreview.src,
                ...imageData.inBetweenFrames,
                endingPngPreview.src
            ];
            
            // Reset animation state
            animationState.currentFrame = 0;
            animationState.isPlaying = false;
            animationState.fps = parseInt(fpsInput.value) || 12;
            
            // Clear any existing animation
            if (animationState.animationInterval) {
                clearInterval(animationState.animationInterval);
                animationState.animationInterval = null;
            }
            
            // Set initial frame
            animationPreview.src = animationState.frames[0];
            updateFrameInfo();
        }

        // Play animation
        function playAnimation() {
            if (animationState.isPlaying) return;
            if (animationState.frames.length <= 1) return;
            
            animationState.isPlaying = true;
            
            // Set up animation interval
            const frameTime = 1000 / animationState.fps;
            animationState.animationInterval = setInterval(() => {
                // Advance to next frame
                animationState.currentFrame++;
                
                // Handle loop or end
                if (animationState.currentFrame >= animationState.frames.length) {
                    if (animationState.isLooping) {
                        animationState.currentFrame = 0;
                    } else {
                        animationState.currentFrame = animationState.frames.length - 1;
                        pauseAnimation();
                        return;
                    }
                }
                
                // Update the preview image
                animationPreview.src = animationState.frames[animationState.currentFrame];
                
                // Update frame info and progress bar
                updateFrameInfo();
            }, frameTime);
        }

        // Pause animation
        function pauseAnimation() {
            if (!animationState.isPlaying) return;
            
            animationState.isPlaying = false;
            
            // Clear animation interval
            if (animationState.animationInterval) {
                clearInterval(animationState.animationInterval);
                animationState.animationInterval = null;
            }
        }

        // Toggle animation looping
        function toggleLoop() {
            animationState.isLooping = !animationState.isLooping;
            loopToggleButton.textContent = `Loop: ${animationState.isLooping ? 'On' : 'Off'}`;
        }

        // Update frame info and progress bar
        function updateFrameInfo() {
            const totalFrames = animationState.frames.length;
            frameInfo.textContent = `Frame ${animationState.currentFrame + 1}/${totalFrames}`;
            
            // Update progress bar
            const progress = (animationState.currentFrame / (totalFrames - 1)) * 100;
            progressBar.style.width = `${progress}%`;
        }

        // Initialize status message and easing visualization
        statusMessage.textContent = "Upload your starting and ending PNG images to begin.";
        updateEasingVisualization();
    </script>
</body>
</html>
